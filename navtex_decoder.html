<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAVTEX Decoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 25px;
            color: #a8d0ff;
            font-size: 1.1em;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #4CAF50;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .instructions ul {
            margin-left: 20px;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #startBtn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        #startBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        #startBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #stopBtn {
            background: linear-gradient(135deg, #f44336, #da190b);
            color: white;
        }

        #stopBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        #stopBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #2196F3, #0b7dda);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .status {
            flex: 1;
            min-width: 200px;
        }

        .status-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .status-label {
            font-weight: bold;
            color: #a8d0ff;
            margin-right: 10px;
        }

        .status-value {
            color: #4CAF50;
            font-weight: bold;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .panel-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #4CAF50;
            border-bottom: 2px solid rgba(76, 175, 80, 0.3);
            padding-bottom: 8px;
        }

        #waterfall {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 6px;
            display: block;
        }

        #signalMeter {
            width: 100%;
            height: 30px;
            background: #000;
            border-radius: 6px;
            margin-top: 10px;
        }

        #decodedText {
            width: 100%;
            height: 300px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 10px;
            border-radius: 6px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        #messageLog {
            width: 100%;
            height: 400px;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 10px;
            border-radius: 6px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        .message-entry {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #2196F3;
        }

        .message-header {
            color: #4CAF50;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .message-time {
            color: #888;
            font-size: 0.9em;
        }

        .message-content {
            color: #ddd;
            margin-top: 5px;
            white-space: pre-wrap;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .filter-controls label {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .filter-controls label:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .filter-controls input[type="checkbox"] {
            margin-right: 5px;
        }

        .signal-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1.5s infinite;
        }

        .signal-good {
            background: #4CAF50;
        }

        .signal-weak {
            background: #FFC107;
        }

        .signal-none {
            background: #666;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .receiving-indicator {
            display: inline-block;
            padding: 4px 12px;
            background: #4CAF50;
            border-radius: 4px;
            font-weight: bold;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        select {
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            cursor: pointer;
        }

        .tune-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .tune-controls input[type="range"] {
            flex: 1;
        }

        .tone-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä NAVTEX Decoder</h1>
        <div class="subtitle">Maritime Safety Information Decoder ‚Ä¢ 518 kHz / 490 kHz</div>

        <div class="instructions">
            <h3>üì° How to Use:</h3>
            <ul>
                <li>Connect your NAVTEX receiver's audio output to your computer's line-in or microphone input</li>
                <li>Alternatively, play NAVTEX audio recordings through your speakers and use your microphone</li>
                <li>Click "Start Decoding" and allow microphone access when prompted</li>
                <li>Adjust the center frequency if needed (default 1530 Hz for standard audio output)</li>
                <li>The decoder expects BFSK audio with 170 Hz shift at 100 baud</li>
                <li>Messages start with "ZCZC" and end with "NNNN"</li>
            </ul>
        </div>

        <div class="controls">
            <button id="startBtn">Start Decoding</button>
            <button id="stopBtn" disabled>Stop Decoding</button>
            <button class="btn-secondary" id="clearBtn">Clear Messages</button>
            <button class="btn-secondary" id="exportBtn">Export Messages</button>
            <div class="status">
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-value" id="statusText">Idle</span>
                    <span class="signal-indicator signal-none" id="signalIndicator"></span>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="panel">
                <div class="panel-title">üìä Spectrum Waterfall</div>
                <canvas id="waterfall"></canvas>
                <canvas id="signalMeter"></canvas>
                <div class="tune-controls">
                    <label>Center Freq: <span id="centerFreqValue">1530</span> Hz</label>
                    <input type="range" id="centerFreq" min="1000" max="2000" value="1530" step="1">
                </div>
                <div class="tone-display">
                    Mark: <span id="markFreq">1445</span> Hz | Space: <span id="spaceFreq">1615</span> Hz
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìù Live Decoded Text</div>
                <div id="decodedText"></div>
                <div style="margin-top: 10px;">
                    <span id="receivingIndicator" style="display: none;" class="receiving-indicator">RECEIVING MESSAGE</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üì® Message Log</div>
            <div class="filter-controls">
                <label><input type="checkbox" class="subject-filter" value="A" checked> A-Navigational Warnings</label>
                <label><input type="checkbox" class="subject-filter" value="B" checked> B-Meteorological Warnings</label>
                <label><input type="checkbox" class="subject-filter" value="C" checked> C-Ice Reports</label>
                <label><input type="checkbox" class="subject-filter" value="D" checked> D-SAR Information</label>
                <label><input type="checkbox" class="subject-filter" value="E" checked> E-Meteorological Forecasts</label>
                <label><input type="checkbox" class="subject-filter" value="L" checked> L-Navigational Warnings (Local)</label>
            </div>
            <div id="messageLog"></div>
        </div>
    </div>

    <script>
        // NAVTEX Decoder Implementation
        class NAVTEXDecoder {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.scriptProcessor = null;
                
                // FSK parameters
                this.sampleRate = 48000;
                this.baudRate = 100;
                this.fskShift = 170;
                this.centerFrequency = 1530; // Default center frequency
                this.markFrequency = this.centerFrequency - (this.fskShift / 2);
                this.spaceFrequency = this.centerFrequency + (this.fskShift / 2);
                
                // Decoding state
                this.bitBuffer = [];
                this.characterBuffer = [];
                this.currentMessage = '';
                this.inMessage = false;
                this.fecBuffer = []; // For Forward Error Correction
                
                // Signal processing
                this.samplesPerBit = this.sampleRate / this.baudRate;
                this.sampleCounter = 0;
                this.lastBit = 0;
                this.bitHistory = [];
                
                // Waterfall display
                this.waterfallCanvas = document.getElementById('waterfall');
                this.waterfallCtx = this.waterfallCanvas.getContext('2d');
                this.signalMeterCanvas = document.getElementById('signalMeter');
                this.signalMeterCtx = this.signalMeterCanvas.getContext('2d');
                this.waterfallData = [];
                
                this.setupUI();
                this.initializeCCIR476Table();
            }

            setupUI() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearMessages());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportMessages());
                
                document.getElementById('centerFreq').addEventListener('input', (e) => {
                    this.centerFrequency = parseInt(e.target.value);
                    this.markFrequency = this.centerFrequency - (this.fskShift / 2);
                    this.spaceFrequency = this.centerFrequency + (this.fskShift / 2);
                    document.getElementById('centerFreqValue').textContent = this.centerFrequency;
                    document.getElementById('markFreq').textContent = Math.round(this.markFrequency);
                    document.getElementById('spaceFreq').textContent = Math.round(this.spaceFrequency);
                });

                // Set up canvas sizes
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
            }

            resizeCanvases() {
                const waterfallRect = this.waterfallCanvas.getBoundingClientRect();
                this.waterfallCanvas.width = waterfallRect.width;
                this.waterfallCanvas.height = waterfallRect.height;
                
                const meterRect = this.signalMeterCanvas.getBoundingClientRect();
                this.signalMeterCanvas.width = meterRect.width;
                this.signalMeterCanvas.height = meterRect.height;
            }

            initializeCCIR476Table() {
                // CCIR 476 7-bit character encoding (ITA-2 variant)
                // Format: 7-bit code -> character
                this.ccir476 = {
                    // Letters mode
                    0b0000011: 'A', 0b0011001: 'B', 0b0001110: 'C', 0b0010010: 'D',
                    0b0010000: 'E', 0b0010110: 'F', 0b0011010: 'G', 0b0000101: 'H',
                    0b0001100: 'I', 0b0011011: 'J', 0b0011110: 'K', 0b0010011: 'L',
                    0b0001011: 'M', 0b0001101: 'N', 0b0011100: 'O', 0b0010110: 'P',
                    0b0011101: 'Q', 0b0001010: 'R', 0b0010100: 'S', 0b0000001: 'T',
                    0b0011100: 'U', 0b0001111: 'V', 0b0011001: 'W', 0b0010111: 'X',
                    0b0010101: 'Y', 0b0010001: 'Z',
                    
                    // Special characters
                    0b0000100: '\r', // Carriage return
                    0b0000010: '\n', // Line feed
                    0b0100000: ' ',  // Space
                    0b0001001: ' ',  // Space (alternate)
                    0b0011111: ' ',  // Letters shift
                    0b0011011: ' ',  // Figures shift
                };

                // Simplified mapping for common patterns
                this.simpleMapping = {
                    0b0000011: 'A', 0b0011001: 'B', 0b0001110: 'C', 0b0010010: 'D',
                    0b0010000: 'E', 0b0010110: 'F', 0b0011010: 'G', 0b0000101: 'H',
                    0b0001100: 'I', 0b0011011: 'J', 0b0011110: 'K', 0b0010011: 'L',
                    0b0001011: 'M', 0b0001101: 'N', 0b0011100: 'O', 0b0010110: 'P',
                    0b0011101: 'Q', 0b0001010: 'R', 0b0010100: 'S', 0b0000001: 'T',
                    0b0011100: 'U', 0b0001111: 'V', 0b0011001: 'W', 0b0010111: 'X',
                    0b0010101: 'Y', 0b0010001: 'Z',
                    0b0000100: '\r', 0b0000010: '\n', 0b0100000: ' ', 0b0001001: ' ',
                    0b0000110: '0', 0b0100111: '1', 0b0100011: '2', 0b0000001: '3',
                    0b0001010: '4', 0b0010000: '5', 0b0010101: '6', 0b0000111: '7',
                    0b0000110: '8', 0b0011000: '9',
                    0b0010110: '.', 0b0001000: ',', 0b0011110: ':', 0b0010011: '?',
                    0b0100110: '\'', 0b0100001: '-', 0b0011101: '(', 0b0001001: ')',
                    0b0010111: '/', 0b0101101: '=', 0b0100100: '+',
                };
            }

            async start() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate
                    });
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.3;
                    
                    // Create script processor for real-time processing
                    const bufferSize = 4096;
                    this.scriptProcessor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
                    
                    this.scriptProcessor.onaudioprocess = (e) => {
                        this.processAudio(e.inputBuffer.getChannelData(0));
                    };
                    
                    this.microphone.connect(this.analyser);
                    this.analyser.connect(this.scriptProcessor);
                    this.scriptProcessor.connect(this.audioContext.destination);
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('statusText').textContent = 'Decoding...';
                    
                    this.startWaterfallDisplay();
                    
                } catch (error) {
                    console.error('Error starting decoder:', error);
                    alert('Error accessing microphone. Please ensure you have granted permission.');
                }
            }

            stop() {
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                    this.scriptProcessor = null;
                }
                if (this.analyser) {
                    this.analyser.disconnect();
                    this.analyser = null;
                }
                if (this.microphone) {
                    this.microphone.disconnect();
                    this.microphone = null;
                }
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('statusText').textContent = 'Idle';
                document.getElementById('signalIndicator').className = 'signal-indicator signal-none';
                
                if (this.waterfallAnimationFrame) {
                    cancelAnimationFrame(this.waterfallAnimationFrame);
                }
            }

            processAudio(samples) {
                // Process each sample for FSK demodulation
                for (let i = 0; i < samples.length; i++) {
                    // Goertzel algorithm for tone detection
                    const markMagnitude = this.goertzelMagnitude(samples, i, this.markFrequency);
                    const spaceMagnitude = this.goertzelMagnitude(samples, i, this.spaceFrequency);
                    
                    // Determine bit based on which tone is stronger
                    const currentBit = markMagnitude > spaceMagnitude ? 1 : 0;
                    
                    this.sampleCounter++;
                    
                    // Sample at the middle of each bit period
                    if (this.sampleCounter >= this.samplesPerBit) {
                        this.sampleCounter = 0;
                        this.processBit(currentBit);
                    }
                }
            }

            goertzelMagnitude(samples, index, frequency) {
                // Simplified Goertzel for real-time processing
                // Use a small window around the current sample
                const windowSize = 100;
                const startIdx = Math.max(0, index - windowSize);
                const endIdx = Math.min(samples.length, index + 1);
                
                const k = Math.round((windowSize * frequency) / this.sampleRate);
                const w = (2.0 * Math.PI * k) / windowSize;
                const cosine = Math.cos(w);
                const sine = Math.sin(w);
                const coeff = 2.0 * cosine;
                
                let q0 = 0, q1 = 0, q2 = 0;
                
                for (let i = startIdx; i < endIdx; i++) {
                    q0 = coeff * q1 - q2 + samples[i];
                    q2 = q1;
                    q1 = q0;
                }
                
                const real = q1 - q2 * cosine;
                const imag = q2 * sine;
                
                return Math.sqrt(real * real + imag * imag);
            }

            processBit(bit) {
                this.bitBuffer.push(bit);
                
                // Wait for 7 bits to form a character
                if (this.bitBuffer.length >= 7) {
                    const charBits = this.bitBuffer.splice(0, 7);
                    const charValue = this.bitsToValue(charBits);
                    this.processCharacter(charValue);
                }
            }

            bitsToValue(bits) {
                let value = 0;
                for (let i = 0; i < bits.length; i++) {
                    value = (value << 1) | bits[i];
                }
                return value;
            }

            processCharacter(charValue) {
                // Add to FEC buffer (characters are sent twice with 3-char delay)
                this.fecBuffer.push(charValue);
                
                if (this.fecBuffer.length >= 4) {
                    // Compare current character with one sent 3 positions ago
                    const currentChar = this.fecBuffer[this.fecBuffer.length - 1];
                    const delayedChar = this.fecBuffer[this.fecBuffer.length - 4];
                    
                    // Simple FEC: use character if they match, otherwise use most recent
                    const finalChar = (currentChar === delayedChar) ? currentChar : currentChar;
                    
                    this.decodeCharacter(finalChar);
                    
                    // Keep buffer size manageable
                    if (this.fecBuffer.length > 10) {
                        this.fecBuffer.shift();
                    }
                }
            }

            decodeCharacter(charValue) {
                // Try to decode using CCIR 476 table
                let char = this.simpleMapping[charValue];
                
                if (!char) {
                    // Try alternative mappings or output as hex
                    char = '';
                }
                
                if (char) {
                    this.currentMessage += char;
                    this.updateDecodedText(char);
                    
                    // Check for message start
                    if (this.currentMessage.includes('ZCZC')) {
                        this.inMessage = true;
                        document.getElementById('receivingIndicator').style.display = 'inline-block';
                        document.getElementById('signalIndicator').className = 'signal-indicator signal-good';
                    }
                    
                    // Check for message end
                    if (this.currentMessage.includes('NNNN') && this.inMessage) {
                        this.inMessage = false;
                        document.getElementById('receivingIndicator').style.display = 'none';
                        this.saveMessage(this.currentMessage);
                        this.currentMessage = '';
                    }
                    
                    // Limit buffer size
                    if (this.currentMessage.length > 2000) {
                        this.currentMessage = this.currentMessage.slice(-1000);
                    }
                }
            }

            updateDecodedText(char) {
                const textDiv = document.getElementById('decodedText');
                textDiv.textContent += char;
                textDiv.scrollTop = textDiv.scrollHeight;
            }

            saveMessage(message) {
                // Extract message components
                const zczcIndex = message.indexOf('ZCZC');
                const nnnnIndex = message.indexOf('NNNN');
                
                if (zczcIndex === -1 || nnnnIndex === -1) return;
                
                const fullMessage = message.substring(zczcIndex, nnnnIndex + 4);
                
                // Parse header: ZCZC + B1B2B3B4
                let header = '';
                let station = '';
                let subject = '';
                let serial = '';
                
                if (fullMessage.length >= 8) {
                    header = fullMessage.substring(4, 8);
                    station = header[0] || '?';
                    subject = header[1] || '?';
                    serial = header.substring(2, 4) || '??';
                }
                
                const content = fullMessage.substring(8, fullMessage.length - 4);
                
                const messageObj = {
                    timestamp: new Date().toISOString(),
                    station: station,
                    subject: subject,
                    serial: serial,
                    content: content,
                    fullMessage: fullMessage
                };
                
                // Save to localStorage
                let messages = JSON.parse(localStorage.getItem('navtexMessages') || '[]');
                messages.push(messageObj);
                localStorage.setItem('navtexMessages', JSON.stringify(messages));
                
                this.displayMessage(messageObj);
            }

            displayMessage(messageObj) {
                const subjectDescriptions = {
                    'A': 'Navigational Warnings',
                    'B': 'Meteorological Warnings',
                    'C': 'Ice Reports',
                    'D': 'Search and Rescue Information',
                    'E': 'Meteorological Forecasts',
                    'F': 'Pilot Service Messages',
                    'G': 'Decca Messages',
                    'H': 'Loran Messages',
                    'I': 'Omega Messages',
                    'J': 'Satnav Messages',
                    'K': 'Other Electronic Navaid Messages',
                    'L': 'Navigational Warnings (Local)',
                    'V': 'Notice to Fishermen',
                    'W': 'Environmental',
                    'X': 'Special Services',
                    'Y': 'Special Services',
                    'Z': 'No Messages on Hand'
                };
                
                const stationCodes = {
                    'A': 'Rogaland', 'B': 'Niton', 'C': 'Valentia', 'D': 'Oostende',
                    'E': 'Tallinn', 'F': 'Bordeaux', 'G': 'Cullercoats', 'H': 'Kerkyra',
                    'I': 'Rome', 'J': 'Tallinn', 'K': 'Gdynia', 'L': 'La Coruna',
                    'M': 'Bergen', 'N': 'Murmansk', 'O': 'Lyngby', 'P': 'Kaliningrad',
                    'Q': 'Stockholm', 'R': 'Las Palmas', 'S': 'Arkhangelsk', 'T': 'Istanbul',
                    'U': 'Constanta', 'V': 'Portishead', 'W': 'UK Station', 'X': 'Murmansk'
                };
                
                const logDiv = document.getElementById('messageLog');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-entry';
                messageDiv.dataset.subject = messageObj.subject;
                
                const time = new Date(messageObj.timestamp).toLocaleString();
                const stationName = stationCodes[messageObj.station] || 'Unknown';
                const subjectDesc = subjectDescriptions[messageObj.subject] || 'Unknown';
                
                messageDiv.innerHTML = `
                    <div class="message-header">
                        üì° Station: ${stationName} (${messageObj.station}) | 
                        Type: ${subjectDesc} (${messageObj.subject}) | 
                        Serial: ${messageObj.serial}
                    </div>
                    <div class="message-time">üïê ${time}</div>
                    <div class="message-content">${this.escapeHtml(messageObj.content)}</div>
                `;
                
                logDiv.insertBefore(messageDiv, logDiv.firstChild);
                this.applyMessageFilters();
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            clearMessages() {
                if (confirm('Clear all messages from log and storage?')) {
                    localStorage.removeItem('navtexMessages');
                    document.getElementById('messageLog').innerHTML = '';
                    document.getElementById('decodedText').textContent = '';
                    this.currentMessage = '';
                }
            }

            exportMessages() {
                const messages = JSON.parse(localStorage.getItem('navtexMessages') || '[]');
                if (messages.length === 0) {
                    alert('No messages to export.');
                    return;
                }
                
                let exportText = 'NAVTEX Messages Export\n';
                exportText += '='.repeat(50) + '\n\n';
                
                messages.forEach(msg => {
                    exportText += `Timestamp: ${msg.timestamp}\n`;
                    exportText += `Station: ${msg.station} | Subject: ${msg.subject} | Serial: ${msg.serial}\n`;
                    exportText += `Message:\n${msg.fullMessage}\n`;
                    exportText += '-'.repeat(50) + '\n\n';
                });
                
                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `navtex_messages_${new Date().toISOString().slice(0, 10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }

            startWaterfallDisplay() {
                const draw = () => {
                    if (!this.analyser) return;
                    
                    const bufferLength = this.analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // Draw waterfall
                    this.drawWaterfall(dataArray);
                    
                    // Draw signal meter
                    this.drawSignalMeter(dataArray);
                    
                    this.waterfallAnimationFrame = requestAnimationFrame(draw);
                };
                
                draw();
            }

            drawWaterfall(frequencyData) {
                const canvas = this.waterfallCanvas;
                const ctx = this.waterfallCtx;
                const width = canvas.width;
                const height = canvas.height;
                
                // Shift existing data down
                const imageData = ctx.getImageData(0, 0, width, height - 1);
                ctx.putImageData(imageData, 0, 1);
                
                // Draw new line at top
                const binWidth = width / frequencyData.length;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const value = frequencyData[i];
                    const hue = 240 - (value / 255) * 240; // Blue to red
                    const saturation = 100;
                    const lightness = 50;
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(i * binWidth, 0, binWidth, 1);
                }
            }

            drawSignalMeter(frequencyData) {
                const canvas = this.signalMeterCanvas;
                const ctx = this.signalMeterCtx;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw frequency bars
                const binWidth = width / frequencyData.length;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const value = frequencyData[i];
                    const barHeight = (value / 255) * height;
                    
                    const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
                    gradient.addColorStop(0, '#4CAF50');
                    gradient.addColorStop(0.5, '#FFC107');
                    gradient.addColorStop(1, '#f44336');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(i * binWidth, height - barHeight, binWidth, barHeight);
                }
                
                // Mark center frequency and FSK tones
                const nyquist = this.sampleRate / 2;
                const markPos = (this.markFrequency / nyquist) * width;
                const spacePos = (this.spaceFrequency / nyquist) * width;
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(markPos, 0);
                ctx.lineTo(markPos, height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(spacePos, 0);
                ctx.lineTo(spacePos, height);
                ctx.stroke();
            }

            loadStoredMessages() {
                const messages = JSON.parse(localStorage.getItem('navtexMessages') || '[]');
                messages.reverse().forEach(msg => this.displayMessage(msg));
            }

            applyMessageFilters() {
                const filters = Array.from(document.querySelectorAll('.subject-filter:checked')).map(cb => cb.value);
                const messages = document.querySelectorAll('.message-entry');
                
                messages.forEach(msg => {
                    const subject = msg.dataset.subject;
                    msg.style.display = filters.includes(subject) ? 'block' : 'none';
                });
            }
        }

        // Initialize decoder
        const decoder = new NAVTEXDecoder();
        decoder.loadStoredMessages();

        // Set up filter checkboxes
        document.querySelectorAll('.subject-filter').forEach(checkbox => {
            checkbox.addEventListener('change', () => decoder.applyMessageFilters());
        });
    </script>
</body>
</html>